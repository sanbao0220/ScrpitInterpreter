<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/conpoments/Loader.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/conpoments/Loader.py" />
              <option name="originalContent" value="import json&#10;from pathlib import Path&#10;from typing import Dict, Any&#10;&#10;&#10;class Loader:&#10;    &quot;&quot;&quot;脚本加载器&quot;&quot;&quot;&#10;&#10;    @staticmethod&#10;    def load_from_json(filepath: Path) -&gt; Dict[str, Any]:&#10;        &quot;&quot;&quot;从 JSON 文件加载脚本数据&quot;&quot;&quot;&#10;        try:&#10;            with open(filepath, 'r', encoding='utf-8') as f:&#10;                script_data = json.load(f)&#10;            return script_data&#10;        except Exception as e:&#10;            raise RuntimeError(f&quot;脚本加载失败: {e}&quot;)&#10;" />
              <option name="updatedContent" value="import json&#10;from pathlib import Path&#10;from typing import Dict, Any&#10;&#10;&#10;class Loader:&#10;    &quot;&quot;&quot;脚本加载器&quot;&quot;&quot;&#10;&#10;    @staticmethod&#10;    def load_from_json(filepath: Path) -&gt; Dict[str, Any]:&#10;        &quot;&quot;&quot;从 JSON 文件加载脚本数据&quot;&quot;&quot;&#10;        try:&#10;            with open(filepath, 'r', encoding='utf-8') as f:&#10;                script_data = json.load(f)&#10;            return script_data&#10;        except Exception as e:&#10;            raise RuntimeError(f&quot;脚本加载失败: {e}&quot;)&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/scripts/Interpreter.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/scripts/Interpreter.py" />
              <option name="originalContent" value="from abc import ABC, abstractmethod&#10;from typing import Dict, Any, Optional, List&#10;import json&#10;from pathlib import Path&#10;from src.ast_nodes import ASTNode, ASTree&#10;from src.conpoments.Loader import Loader&#10;from src.conpoments.ASTBuilder import ASTBuilder&#10;from src.conpoments.Executor import Executor&#10;&#10;&#10;&#10;# === 上下文类 ===&#10;class Context:&#10;    &quot;&quot;&quot;执行上下文&quot;&quot;&quot;&#10;&#10;    def __init__(self):&#10;        self.variables: Dict[str, Any] = {}&#10;        self.services: Dict[str, Any] = {}&#10;        self.current_node: Optional[ASTNode] = None&#10;        self.execution_history: List[str] = []&#10;        self.intention: Optional[str] = None  # 当前识别到的意图（可由外部或 LLM 填充）&#10;&#10;&#10;# === 最后定义脚本基类 ===&#10;class BaseScript(ABC):&#10;    &quot;&quot;&quot;脚本基类（最后定义，避免循环引用）&quot;&quot;&quot;&#10;&#10;    def __init__(self, script_path: Path):&#10;        &quot;&quot;&quot;初始化脚本，加载 JSON 并构建语法树&quot;&quot;&quot;&#10;        self._ast: Optional[ASTree] = None&#10;        self.metadata = {'script_type': self.__class__.__name__}&#10;        self._script_data: Dict[str, Any] = {}&#10;        self.intention = '沉默'  # 默认意图名称（与脚本中的 branch key 对应）&#10;&#10;        try:&#10;            # 使用 Loader 加载脚本数据&#10;            self._script_data = Loader.load_from_json(script_path)&#10;            self.metadata.update(self._script_data.get('metadata', {}))&#10;            # 调用 ASTBuilder 构建语法树&#10;            self._ast = ASTBuilder.build_ast_with_validation(self._script_data)&#10;            self._log(f&quot;脚本加载成功: {script_path}&quot;)&#10;        except Exception as e:&#10;            raise RuntimeError(f&quot;脚本初始化失败: {e}&quot;)&#10;&#10;    def execute(self, context: Context) -&gt; Dict[str, Any]:&#10;        &quot;&quot;&quot;驱动语法树执行&quot;&quot;&quot;&#10;        if not self._ast:&#10;            raise RuntimeError(&quot;未构建语法树&quot;)&#10;&#10;        # 从 welcome 开始&#10;        current = self._ast.get_node('welcome')&#10;        context.current_node = current&#10;        results = {}&#10;&#10;        while current:&#10;            # 将动作执行视为节点方法&#10;            current.perform_actions(context, self._log)&#10;&#10;            # 记录变量快照和历史&#10;            results[current.name] = context.variables.copy()&#10;            context.execution_history.append(current.name)&#10;&#10;            # 决策下一个节点名：优先使用 context.intention，否则使用脚本默认 self.intention&#10;            use_intent = context.intention if context.intention is not None else self.intention&#10;            next_node = self._ast.get_next_node(current.name, use_intent)&#10;&#10;            # 更新当前节点&#10;            context.current_node = next_node&#10;            current = next_node&#10;&#10;        return results&#10;&#10;&#10;    def _log(self, message: str):&#10;        &quot;&quot;&quot;内置日志&quot;&quot;&quot;&#10;        print(f&quot;[{self.metadata['script_type']}] {message}&quot;)&#10;" />
              <option name="updatedContent" value="from abc import ABC, abstractmethod&#10;from typing import Dict, Any, Optional, List&#10;import json&#10;from pathlib import Path&#10;from src.ast_nodes import ASTNode, ASTree&#10;from src.conpoments.Loader import Loader&#10;from src.conpoments.ASTBuilder import ASTBuilder&#10;from src.conpoments.Executor import Executor&#10;&#10;&#10;&#10;# === 上下文类 ===&#10;class Context:&#10;    &quot;&quot;&quot;执行上下文&quot;&quot;&quot;&#10;&#10;    def __init__(self):&#10;        self.variables: Dict[str, Any] = {}&#10;        self.services: Dict[str, Any] = {}&#10;        self.current_node: Optional[ASTNode] = None&#10;        self.execution_history: List[str] = []&#10;        self.intention: Optional[str] = None  # 当前识别到的意图（可由外部或 LLM 填充）&#10;&#10;&#10;# === 最后定义脚本基类 ===&#10;class BaseScript(ABC):&#10;    &quot;&quot;&quot;脚本基类（最后定义，避免循环引用）&quot;&quot;&quot;&#10;&#10;    def __init__(self, script_path: Path):&#10;        &quot;&quot;&quot;初始化脚本，加载 JSON 并构建语法树&quot;&quot;&quot;&#10;        self._ast: Optional[ASTree] = None&#10;        self.metadata = {'script_type': self.__class__.__name__}&#10;        self._script_data: Dict[str, Any] = {}&#10;        self.intention = '沉默'  # 默认意图名称（与脚本中的 branch key 对应）&#10;&#10;        try:&#10;            # 使用 Loader 加载脚本数据&#10;            self._script_data = Loader.load_from_json(script_path)&#10;            self.metadata.update(self._script_data.get('metadata', {}))&#10;            # 调用 ASTBuilder 构建语法树&#10;            self._ast = ASTBuilder.build_ast_with_validation(self._script_data)&#10;            self._log(f&quot;脚本加载成功: {script_path}&quot;)&#10;        except Exception as e:&#10;            raise RuntimeError(f&quot;脚本初始化失败: {e}&quot;)&#10;&#10;    def execute(self, context: Context) -&gt; Dict[str, Any]:&#10;        &quot;&quot;&quot;驱动语法树执行&quot;&quot;&quot;&#10;        if not self._ast:&#10;            raise RuntimeError(&quot;未构建语法树&quot;)&#10;&#10;        # 从 welcome 开始&#10;        current = self._ast.get_node('welcome')&#10;        context.current_node = current&#10;        results = {}&#10;&#10;        while current:&#10;            # 将动作执行视为节点方法&#10;            current.perform_actions(context, self._log)&#10;&#10;            # 记录变量快照和历史&#10;            results[current.name] = context.variables.copy()&#10;            context.execution_history.append(current.name)&#10;&#10;            # 决策下一个节点名：优先使用 context.intention，否则使用脚本默认 self.intention&#10;            use_intent = context.intention if context.intention is not None else self.intention&#10;            next_node = self._ast.get_next_node(current.name, use_intent)&#10;&#10;            # 更新当前节点&#10;            context.current_node = next_node&#10;            current = next_node&#10;&#10;        return results&#10;&#10;&#10;    def _log(self, message: str):&#10;        &quot;&quot;&quot;内置日志&quot;&quot;&quot;&#10;        print(f&quot;[{self.metadata['script_type']}] {message}&quot;)" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>