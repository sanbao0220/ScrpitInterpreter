<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/conpoments/Ast1.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/conpoments/Ast1.py" />
              <option name="originalContent" value="&quot;&quot;&quot;&#10;新版语法分析树（AST）模块&#10;&#10;功能：&#10;- ASTNode1：节点结构，包含名称、动作、分支、条件分支（if）&#10;- ASTree1：树结构，管理所有节点，支持从json脚本构建分析树&#10;- from_json_script：将json脚本文件转换为ASTree1对象&#10;&#10;用法示例：&#10;    tree = from_json_script('jd_service_script.json')&#10;    node = tree.get_node('welcome')&#10;    next_node = tree.get_next_node('welcome', '投诉')&#10;&quot;&quot;&quot;&#10;&#10;import json&#10;from typing import Dict, Any, Optional, List&#10;&#10;class ASTNode1:&#10;    &quot;&quot;&quot;新版语法分析树节点&quot;&quot;&quot;&#10;    def __init__(self, name: str, actions: Dict[str, Any], branch: Dict[str, str], ifs: Optional[List[Dict[str, Any]]] = None):&#10;        self.name = name&#10;        self.actions = actions&#10;        self.branch = branch&#10;        self.ifs = ifs or []&#10;&#10;    def get_next_node_name(self, intention: str, context: Dict[str, Any] = None) -&gt; Optional[str]:&#10;        &quot;&quot;&quot;&#10;        根据意图和条件分支获取下一个节点名称&#10;        :param intention: 用户意图&#10;        :param context: 当前变量上下文（用于条件判断）&#10;        :return: 下一个节点名称&#10;        &quot;&quot;&quot;&#10;        # 优先处理条件分支&#10;        if context and self.ifs:&#10;            for cond in self.ifs:&#10;                try:&#10;                    # 简单条件表达式求值（仅支持变量替换和==, !=, &gt;, &lt;, &gt;=, &lt;=）&#10;                    expr = cond['condition']&#10;                    expr_eval = expr&#10;                    for k, v in context.items():&#10;                        expr_eval = expr_eval.replace(f&quot;${k}&quot;, repr(v))&#10;                    if eval(expr_eval):&#10;                        return cond['goto']&#10;                except Exception:&#10;                    continue&#10;        # 普通分支&#10;        return self.branch.get(intention)&#10;&#10;class ASTree1:&#10;    &quot;&quot;&quot;新版语法分析树容器&quot;&quot;&quot;&#10;    def __init__(self):&#10;        self.nodes: Dict[str, ASTNode1] = {}&#10;        self.data_buffer: Dict[str, Any] = {}  # 数据缓冲区，执行时用于存储和访问用户数据&#10;        self.input_buffer: Dict[str, Any] = {} # 输入缓冲区，存储listen内容&#10;&#10;    def add_node(self, node: ASTNode1):&#10;        self.nodes[node.name] = node&#10;&#10;    def get_node(self, name: str) -&gt; Optional[ASTNode1]:&#10;        return self.nodes.get(name)&#10;&#10;    def get_next_node(self, current_node_name: str, intention: str, context: Dict[str, Any] = None) -&gt; Optional[ASTNode1]:&#10;        node = self.get_node(current_node_name)&#10;        if not node:&#10;            return None&#10;        next_name = node.get_next_node_name(intention, context)&#10;        return self.get_node(next_name) if next_name else None&#10;&#10;    def run(self, start_node: str, context: Dict[str, Any] = None, input_func=None, output_func=None):&#10;        &quot;&quot;&quot;&#10;        从指定节点开始自动执行脚本流程&#10;        :param start_node: 起始节点名称&#10;        :param context: 变量上下文（如用户数据），会同步到数据缓冲区&#10;        :param input_func: 获取用户输入的函数（可自定义，默认input）&#10;        :param output_func: 输出函数（可自定义，默认print）&#10;        &quot;&quot;&quot;&#10;        if input_func is None:&#10;            input_func = input&#10;        if output_func is None:&#10;            output_func = print&#10;&#10;        # 初始化数据缓冲区&#10;        if context:&#10;            self.data_buffer.update(context)&#10;        self.input_buffer.clear()&#10;&#10;        current = self.get_node(start_node)&#10;        while current:&#10;            actions = current.actions&#10;            # Speak&#10;            if 'speak' in actions:&#10;                text = actions['speak']&#10;                # 变量替换，优先从数据缓冲区读取&#10;                for k, v in self.data_buffer.items():&#10;                    text = text.replace(f&quot;${{{k}}}&quot;, str(v))&#10;                output_func(text)&#10;            # Listen&#10;            user_input = None&#10;            if 'listen' in actions:&#10;                user_input = input_func(&quot;&gt;&gt; &quot;)&#10;                self.input_buffer['listen_content'] = user_input&#10;                # 不再写入 data_buffer['listen_content']&#10;            # 数据更新动作（UPGRATE）&#10;            if 'upgrate' in actions:&#10;                for upd in actions['upgrate']:&#10;                    val = upd['value']&#10;                    # 支持变量引用&#10;                    if isinstance(val, str) and val.startswith(&quot;$&quot;):&#10;                        var_name = val[1:]&#10;                        if var_name == &quot;listen_content&quot;:&#10;                            val = self.input_buffer.get(&quot;listen_content&quot;, &quot;&quot;)&#10;                        else:&#10;                            val = self.data_buffer.get(var_name, val)&#10;                    self.data_buffer[upd['field']] = val&#10;            # Exit 动作处理&#10;            if actions.get('exit', False):&#10;                # 跳转到exit节点并退出&#10;                exit_node = self.get_node('exit')&#10;                if exit_node:&#10;                    actions = exit_node.actions&#10;                    if 'speak' in actions:&#10;                        output_func(actions['speak'])&#10;                break&#10;            # 条件分支&#10;            next_node_name = None&#10;            if current.ifs and self.data_buffer:&#10;                for cond in current.ifs:&#10;                    expr = cond['condition']&#10;                    expr_eval = expr&#10;                    for k, v in self.data_buffer.items():&#10;                        expr_eval = expr_eval.replace(f&quot;${k}&quot;, repr(v))&#10;                    try:&#10;                        if eval(expr_eval):&#10;                            next_node_name = cond['goto']&#10;                            break&#10;                    except Exception:&#10;                        continue&#10;            # 普通分支&#10;            if not next_node_name:&#10;                if user_input and user_input in current.branch:&#10;                    next_node_name = current.branch[user_input]&#10;                elif '意图识别失败' in current.branch:&#10;                    next_node_name = current.branch['意图识别失败']&#10;                elif '结束' in current.branch:&#10;                    next_node_name = current.branch['结束']&#10;                else:&#10;                    next_node_name = None&#10;            if not next_node_name:&#10;                break&#10;            current = self.get_node(next_node_name)&#10;&#10;def from_json_script(json_path: str) -&gt; ASTree1:&#10;    &quot;&quot;&quot;&#10;    从json脚本文件构建新版语法分析树&#10;    :param json_path: json脚本文件路径&#10;    :return: ASTree1对象&#10;    &quot;&quot;&quot;&#10;    with open(json_path, &quot;r&quot;, encoding=&quot;utf-8&quot;) as f:&#10;        script = json.load(f)&#10;    steps = script.get(&quot;steps&quot;, {})&#10;    tree = ASTree1()&#10;    for step_name, step_cfg in steps.items():&#10;        actions = step_cfg.get(&quot;actions&quot;, {})&#10;        branch = step_cfg.get(&quot;branch&quot;, {})&#10;        ifs = step_cfg.get(&quot;if&quot;, [])&#10;        node = ASTNode1(step_name, actions, branch, ifs)&#10;        tree.add_node(node)&#10;    return tree&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    # 测试主流程&#10;    json_path = r&quot;c:\Users\20232\OneDrive\大三上\程序设计与实践\大作业\项目文件\CSBotInterpreter\scripts\jd_service_script.json&quot;&#10;    tree = from_json_script(json_path)&#10;    print(&quot;=== 京东客服脚本自动化测试 ===&quot;)&#10;    # 可自定义初始上下文&#10;    context = {&#10;        &quot;name&quot;: &quot;张三&quot;,&#10;        &quot;is_vip&quot;: True,&#10;        &quot;order_id&quot;: &quot;JD20240001&quot;,&#10;        &quot;status&quot;: &quot;交易成功&quot;,&#10;        &quot;price&quot;: 299.0&#10;    }&#10;    # 运行流程，输入可用：订单、退换货、投诉、人工、意图识别失败&#10;    tree.run(&quot;welcome&quot;, context)&#10;    print(&quot;输入缓冲区内容：&quot;, tree.input_buffer)&#10;" />
              <option name="updatedContent" value="&quot;&quot;&quot;&#10;新版语法分析树（AST）模块&#10;&#10;功能：&#10;- ASTNode1：节点结构，包含名称、动作、分支、条件分支（if）&#10;- ASTree1：树结构，管理所有节点，支持从json脚本构建分析树&#10;- from_json_script：将json脚本文件转换为ASTree1对象&#10;&#10;用法示例：&#10;    tree = from_json_script('jd_service_script.json')&#10;    node = tree.get_node('welcome')&#10;    next_node = tree.get_next_node('welcome', '投诉')&#10;&quot;&quot;&quot;&#10;&#10;import json&#10;from typing import Dict, Any, Optional, List&#10;import os&#10;&#10;class ASTNode1:&#10;    &quot;&quot;&quot;新版语法分析树节点&quot;&quot;&quot;&#10;    def __init__(self, name: str, actions: Dict[str, Any], branch: Dict[str, str], ifs: Optional[List[Dict[str, Any]]] = None):&#10;        self.name = name&#10;        self.actions = actions&#10;        self.branch = branch&#10;        self.ifs = ifs or []&#10;&#10;    def get_next_node_name(self, intention: str, context: Dict[str, Any] = None) -&gt; Optional[str]:&#10;        &quot;&quot;&quot;&#10;        根据意图和条件分支获取下一个节点名称&#10;        :param intention: 用户意图&#10;        :param context: 当前变量上下文（用于条件判断）&#10;        :return: 下一个节点名称&#10;        &quot;&quot;&quot;&#10;        # 优先处理条件分支&#10;        if context and self.ifs:&#10;            for cond in self.ifs:&#10;                try:&#10;                    # 简单条件表达式求值（仅支持变量替换和==, !=, &gt;, &lt;, &gt;=, &lt;=）&#10;                    expr = cond['condition']&#10;                    expr_eval = expr&#10;                    for k, v in context.items():&#10;                        expr_eval = expr_eval.replace(f&quot;${k}&quot;, repr(v))&#10;                    if eval(expr_eval):&#10;                        return cond['goto']&#10;                except Exception:&#10;                    continue&#10;        # 普通分支&#10;        return self.branch.get(intention)&#10;&#10;class ASTree1:&#10;    &quot;&quot;&quot;新版语法分析树容器&quot;&quot;&quot;&#10;    def __init__(self):&#10;        self.nodes: Dict[str, ASTNode1] = {}&#10;        self.data_buffer: Dict[str, Any] = {}  # 数据缓冲区，执行时用于存储和访问用户数据&#10;        self.input_buffer: Dict[str, Any] = {} # 输入缓冲区，存储listen内容&#10;        self.script_name: str = &quot;&quot;  # 新增：脚本文件名（不带扩展名）&#10;&#10;    def add_node(self, node: ASTNode1):&#10;        self.nodes[node.name] = node&#10;&#10;    def get_node(self, name: str) -&gt; Optional[ASTNode1]:&#10;        return self.nodes.get(name)&#10;&#10;    def get_next_node(self, current_node_name: str, intention: str, context: Dict[str, Any] = None) -&gt; Optional[ASTNode1]:&#10;        node = self.get_node(current_node_name)&#10;        if not node:&#10;            return None&#10;        next_name = node.get_next_node_name(intention, context)&#10;        return self.get_node(next_name) if next_name else None&#10;&#10;    def run(self, start_node: str, context: Dict[str, Any] = None, input_func=None, output_func=None):&#10;        &quot;&quot;&quot;&#10;        从指定节点开始自动执行脚本流程&#10;        :param start_node: 起始节点名称&#10;        :param context: 变量上下文（如用户数据），会同步到数据缓冲区&#10;        :param input_func: 获取用户输入的函数（可自定义，默认input）&#10;        :param output_func: 输出函数（可自定义，默认print）&#10;        &quot;&quot;&quot;&#10;        if input_func is None:&#10;            input_func = input&#10;        if output_func is None:&#10;            output_func = print&#10;&#10;        # 初始化数据缓冲区&#10;        if context:&#10;            self.data_buffer.update(context)&#10;        self.input_buffer.clear()&#10;&#10;        current = self.get_node(start_node)&#10;        while current:&#10;            actions = current.actions&#10;            # Speak&#10;            if 'speak' in actions:&#10;                text = actions['speak']&#10;                # 变量替换，优先从数据缓冲区读取&#10;                for k, v in self.data_buffer.items():&#10;                    text = text.replace(f&quot;${{{k}}}&quot;, str(v))&#10;                output_func(text)&#10;            # Listen&#10;            user_input = None&#10;            if 'listen' in actions:&#10;                user_input = input_func(&quot;&gt;&gt; &quot;)&#10;                self.input_buffer['listen_content'] = user_input&#10;                # 不再写入 data_buffer['listen_content']&#10;            # 数据更新动作（UPGRATE）&#10;            if 'upgrate' in actions:&#10;                for upd in actions['upgrate']:&#10;                    val = upd['value']&#10;                    # 支持变量引用&#10;                    if isinstance(val, str) and val.startswith(&quot;$&quot;):&#10;                        var_name = val[1:]&#10;                        if var_name == &quot;listen_content&quot;:&#10;                            val = self.input_buffer.get(&quot;listen_content&quot;, &quot;&quot;)&#10;                        else:&#10;                            val = self.data_buffer.get(var_name, val)&#10;                    self.data_buffer[upd['field']] = val&#10;            # Exit 动作处理&#10;            if actions.get('exit', False):&#10;                # 跳转到exit节点并退出&#10;                exit_node = self.get_node('exit')&#10;                if exit_node:&#10;                    actions = exit_node.actions&#10;                    if 'speak' in actions:&#10;                        output_func(actions['speak'])&#10;                break&#10;            # 条件分支&#10;            next_node_name = None&#10;            if current.ifs and self.data_buffer:&#10;                for cond in current.ifs:&#10;                    expr = cond['condition']&#10;                    expr_eval = expr&#10;                    for k, v in self.data_buffer.items():&#10;                        expr_eval = expr_eval.replace(f&quot;${k}&quot;, repr(v))&#10;                    try:&#10;                        if eval(expr_eval):&#10;                            next_node_name = cond['goto']&#10;                            break&#10;                    except Exception:&#10;                        continue&#10;            # 普通分支&#10;            if not next_node_name:&#10;                if user_input and user_input in current.branch:&#10;                    next_node_name = current.branch[user_input]&#10;                elif '意图识别失败' in current.branch:&#10;                    next_node_name = current.branch['意图识别失败']&#10;                elif '结束' in current.branch:&#10;                    next_node_name = current.branch['结束']&#10;                else:&#10;                    next_node_name = None&#10;            if not next_node_name:&#10;                break&#10;            current = self.get_node(next_node_name)&#10;&#10;def from_json_script(json_path: str) -&gt; ASTree1:&#10;    &quot;&quot;&quot;&#10;    从json脚本文件构建新版语法分析树&#10;    :param json_path: json脚本文件路径&#10;    :return: ASTree1对象&#10;    &quot;&quot;&quot;&#10;    with open(json_path, &quot;r&quot;, encoding=&quot;utf-8&quot;) as f:&#10;        script = json.load(f)&#10;    steps = script.get(&quot;steps&quot;, {})&#10;    tree = ASTree1()&#10;    # 设置 script_name 为文件名（不带扩展名）&#10;    tree.script_name = os.path.splitext(os.path.basename(json_path))[0]&#10;    for step_name, step_cfg in steps.items():&#10;        actions = step_cfg.get(&quot;actions&quot;, {})&#10;        branch = step_cfg.get(&quot;branch&quot;, {})&#10;        ifs = step_cfg.get(&quot;if&quot;, [])&#10;        node = ASTNode1(step_name, actions, branch, ifs)&#10;        tree.add_node(node)&#10;    return tree&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    # 测试主流程&#10;    json_path = r&quot;c:\Users\20232\OneDrive\大三上\程序设计与实践\大作业\项目文件\CSBotInterpreter\scripts\jd_service_script.json&quot;&#10;    tree = from_json_script(json_path)&#10;    print(&quot;=== 京东客服脚本自动化测试 ===&quot;)&#10;    # 可自定义初始上下文&#10;    context = {&#10;        &quot;name&quot;: &quot;张三&quot;,&#10;        &quot;is_vip&quot;: True,&#10;        &quot;order_id&quot;: &quot;JD20240001&quot;,&#10;        &quot;status&quot;: &quot;交易成功&quot;,&#10;        &quot;price&quot;: 299.0&#10;    }&#10;    # 运行流程，输入可用：订单、退换货、投诉、人工、意图识别失败&#10;    tree.run(&quot;welcome&quot;, context)&#10;    print(&quot;输入缓冲区内容：&quot;, tree.input_buffer)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/conpoments/Loader.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/conpoments/Loader.py" />
              <option name="originalContent" value="import json&#10;from pathlib import Path&#10;from typing import Dict, Any&#10;&#10;&#10;class Loader:&#10;    &quot;&quot;&quot;脚本加载器&quot;&quot;&quot;&#10;&#10;    @staticmethod&#10;    def load_from_json(filepath: Path) -&gt; Dict[str, Any]:&#10;        &quot;&quot;&quot;从 JSON 文件加载脚本数据&quot;&quot;&quot;&#10;        try:&#10;            with open(filepath, 'r', encoding='utf-8') as f:&#10;                script_data = json.load(f)&#10;            return script_data&#10;        except Exception as e:&#10;            raise RuntimeError(f&quot;脚本加载失败: {e}&quot;)&#10;" />
              <option name="updatedContent" value="import json&#10;from pathlib import Path&#10;from typing import Dict, Any&#10;&#10;&#10;class Loader:&#10;    &quot;&quot;&quot;脚本加载器&quot;&quot;&quot;&#10;&#10;    @staticmethod&#10;    def load_from_json(filepath: Path) -&gt; Dict[str, Any]:&#10;        &quot;&quot;&quot;从 JSON 文件加载脚本数据&quot;&quot;&quot;&#10;        try:&#10;            with open(filepath, 'r', encoding='utf-8') as f:&#10;                script_data = json.load(f)&#10;            return script_data&#10;        except Exception as e:&#10;            raise RuntimeError(f&quot;脚本加载失败: {e}&quot;)&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/scripts/Interpreter.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/scripts/Interpreter.py" />
              <option name="originalContent" value="from abc import ABC, abstractmethod&#10;from typing import Dict, Any, Optional, List&#10;import json&#10;from pathlib import Path&#10;from src.ast_nodes import ASTNode, ASTree&#10;from src.conpoments.Loader import Loader&#10;from src.conpoments.ASTBuilder import ASTBuilder&#10;from src.conpoments.Executor import Executor&#10;&#10;&#10;&#10;# === 上下文类 ===&#10;class Context:&#10;    &quot;&quot;&quot;执行上下文&quot;&quot;&quot;&#10;&#10;    def __init__(self):&#10;        self.variables: Dict[str, Any] = {}&#10;        self.services: Dict[str, Any] = {}&#10;        self.current_node: Optional[ASTNode] = None&#10;        self.execution_history: List[str] = []&#10;        self.intention: Optional[str] = None  # 当前识别到的意图（可由外部或 LLM 填充）&#10;&#10;&#10;# === 最后定义脚本基类 ===&#10;class BaseScript(ABC):&#10;    &quot;&quot;&quot;脚本基类（最后定义，避免循环引用）&quot;&quot;&quot;&#10;&#10;    def __init__(self, script_path: Path):&#10;        &quot;&quot;&quot;初始化脚本，加载 JSON 并构建语法树&quot;&quot;&quot;&#10;        self._ast: Optional[ASTree] = None&#10;        self.metadata = {'script_type': self.__class__.__name__}&#10;        self._script_data: Dict[str, Any] = {}&#10;        self.intention = '沉默'  # 默认意图名称（与脚本中的 branch key 对应）&#10;&#10;        try:&#10;            # 使用 Loader 加载脚本数据&#10;            self._script_data = Loader.load_from_json(script_path)&#10;            self.metadata.update(self._script_data.get('metadata', {}))&#10;            # 调用 ASTBuilder 构建语法树&#10;            self._ast = ASTBuilder.build_ast_with_validation(self._script_data)&#10;            self._log(f&quot;脚本加载成功: {script_path}&quot;)&#10;        except Exception as e:&#10;            raise RuntimeError(f&quot;脚本初始化失败: {e}&quot;)&#10;&#10;    def execute(self, context: Context) -&gt; Dict[str, Any]:&#10;        &quot;&quot;&quot;驱动语法树执行&quot;&quot;&quot;&#10;        if not self._ast:&#10;            raise RuntimeError(&quot;未构建语法树&quot;)&#10;&#10;        # 从 welcome 开始&#10;        current = self._ast.get_node('welcome')&#10;        context.current_node = current&#10;        results = {}&#10;&#10;        while current:&#10;            # 将动作执行视为节点方法&#10;            current.perform_actions(context, self._log)&#10;&#10;            # 记录变量快照和历史&#10;            results[current.name] = context.variables.copy()&#10;            context.execution_history.append(current.name)&#10;&#10;            # 决策下一个节点名：优先使用 context.intention，否则使用脚本默认 self.intention&#10;            use_intent = context.intention if context.intention is not None else self.intention&#10;            next_node = self._ast.get_next_node(current.name, use_intent)&#10;&#10;            # 更新当前节点&#10;            context.current_node = next_node&#10;            current = next_node&#10;&#10;        return results&#10;&#10;&#10;    def _log(self, message: str):&#10;        &quot;&quot;&quot;内置日志&quot;&quot;&quot;&#10;        print(f&quot;[{self.metadata['script_type']}] {message}&quot;)&#10;" />
              <option name="updatedContent" value="from abc import ABC, abstractmethod&#10;from typing import Dict, Any, Optional, List&#10;import json&#10;from pathlib import Path&#10;from src.ast_nodes import ASTNode, ASTree&#10;from src.conpoments.Loader import Loader&#10;from src.conpoments.ASTBuilder import ASTBuilder&#10;from src.conpoments.Executor import Executor&#10;&#10;&#10;&#10;# === 上下文类 ===&#10;class Context:&#10;    &quot;&quot;&quot;执行上下文&quot;&quot;&quot;&#10;&#10;    def __init__(self):&#10;        self.variables: Dict[str, Any] = {}&#10;        self.services: Dict[str, Any] = {}&#10;        self.current_node: Optional[ASTNode] = None&#10;        self.execution_history: List[str] = []&#10;        self.intention: Optional[str] = None  # 当前识别到的意图（可由外部或 LLM 填充）&#10;&#10;&#10;# === 最后定义脚本基类 ===&#10;class BaseScript(ABC):&#10;    &quot;&quot;&quot;脚本基类（最后定义，避免循环引用）&quot;&quot;&quot;&#10;&#10;    def __init__(self, script_path: Path):&#10;        &quot;&quot;&quot;初始化脚本，加载 JSON 并构建语法树&quot;&quot;&quot;&#10;        self._ast: Optional[ASTree] = None&#10;        self.metadata = {'script_type': self.__class__.__name__}&#10;        self._script_data: Dict[str, Any] = {}&#10;        self.intention = '沉默'  # 默认意图名称（与脚本中的 branch key 对应）&#10;&#10;        try:&#10;            # 使用 Loader 加载脚本数据&#10;            self._script_data = Loader.load_from_json(script_path)&#10;            self.metadata.update(self._script_data.get('metadata', {}))&#10;            # 调用 ASTBuilder 构建语法树&#10;            self._ast = ASTBuilder.build_ast_with_validation(self._script_data)&#10;            self._log(f&quot;脚本加载成功: {script_path}&quot;)&#10;        except Exception as e:&#10;            raise RuntimeError(f&quot;脚本初始化失败: {e}&quot;)&#10;&#10;    def execute(self, context: Context) -&gt; Dict[str, Any]:&#10;        &quot;&quot;&quot;驱动语法树执行&quot;&quot;&quot;&#10;        if not self._ast:&#10;            raise RuntimeError(&quot;未构建语法树&quot;)&#10;&#10;        # 从 welcome 开始&#10;        current = self._ast.get_node('welcome')&#10;        context.current_node = current&#10;        results = {}&#10;&#10;        while current:&#10;            # 将动作执行视为节点方法&#10;            current.perform_actions(context, self._log)&#10;&#10;            # 记录变量快照和历史&#10;            results[current.name] = context.variables.copy()&#10;            context.execution_history.append(current.name)&#10;&#10;            # 决策下一个节点名：优先使用 context.intention，否则使用脚本默认 self.intention&#10;            use_intent = context.intention if context.intention is not None else self.intention&#10;            next_node = self._ast.get_next_node(current.name, use_intent)&#10;&#10;            # 更新当前节点&#10;            context.current_node = next_node&#10;            current = next_node&#10;&#10;        return results&#10;&#10;&#10;    def _log(self, message: str):&#10;        &quot;&quot;&quot;内置日志&quot;&quot;&quot;&#10;        print(f&quot;[{self.metadata['script_type']}] {message}&quot;)" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>